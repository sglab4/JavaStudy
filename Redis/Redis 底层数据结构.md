参考 https://www.php.cn/redis/473191.html

# Redis 底层结构概述

Redis 是一个内存键值key-value 数据库，且键值对数据保存在内存中，因此Redis基于内存的数据操作，其效率高，速度快；其中，Key是String类型，Redis 支持的 value 类型包括了 String、List 、 Hash 、 Set 、 Sorted Set 、BitMap等。Redis 能够之所以能够广泛地适用众多的业务场景，基于其多样化类型的value。

而Redis的Value的数据类型是基于为Redis自定义的对象系统redisObject实现的，

```c
typedef struct redisObject{
    //类型
    unsigned type:4;
    //编码
    unsigned encoding:4;
    //指向底层实现数据结构的指针
    void *ptr;
    ···
}
```

redisObject除了记录实际数据，还需要额外的内存空间记录数据长度、空间使用等元数据信息，其中包含了 8 字节的元数据和一个 8 字节指针，指针指向具体数据类型的实际数据所在位置：

![image.png](https://pict-picgo.oss-cn-hangzhou.aliyuncs.com/picture3/202209202143667.png)

其中，指针指向的就是基于Redis的底层数据结构存储数据的位置，Redis的底层数据结构有 **SDS，双向链表、整数集合、跳表，字典，压缩列表**。

## SDS

简单动态字符串，使用len字段记录已使用的字节数，将获取字符串长度复杂度降低为O(1)，而且SDS是惰性释放空间的，你free了空间，系统把数据记录下来下次想用时候可直接使用。不用新申请空间。

![image.png](https://pict-picgo.oss-cn-hangzhou.aliyuncs.com/picture3/202208281450697.png)

## 整数数组

在内存中分配一块地址连续的空间，数据元素会挨着存放，不需要额外指针带来空间开销，其特点为内存紧凑节省内存空间，查询复杂度为O(1)效率高，其他操作复杂度为O(N)；

## 双向链表

在内存上可以为非连续、非顺序空间，通过额外的指针开销前驱/后驱指针串联元素之间的顺序。其特点为节插入/更新数据复杂度为O(1)效率高，查询复杂度为O(N)；

## 字典（哈希表）

字典，其实类似是一个数组，数组的每个元素称为一个哈希桶，每个哈希桶中保存了键值对数据，且哈希桶中的元素使用dictEntry结构

![image.png](https://pict-picgo.oss-cn-hangzhou.aliyuncs.com/picture3/202208281450269.png)

因此，哈希桶元素保存的并不是键值对值本身，而是指向具体值的指针，所以在保存每个键值对的时候会额外空间开销，至少有增加24个字节，特别是Value为String的键值对，每一个键值对就需要额外开销24个字节空间。当保存数据小，额外开销比数据还大时，这时为了节省空间，考虑换数据结构。

![image.png](https://pict-picgo.oss-cn-hangzhou.aliyuncs.com/picture3/202208281450253.png)

虽然哈希表操作很快，但Redis数据变大后，就会出现一个潜在的风险：哈希表的冲突问题和 rehash开销问题，这可以解释为什么哈希表操作变慢了？

当往哈希表中写入更多数据时，哈希冲突是不可避免的问题 ， Redis 解决哈希冲突的方式，就是链式哈希，同一个哈希桶中的多个元素用一个链表来保存，它们之间依次用指针连接，如图所示

![image.png](https://pict-picgo.oss-cn-hangzhou.aliyuncs.com/picture3/202208281454777.png)

当哈希冲突也会越来越多，这就会导致某些哈希冲突链过长，进而导致这个链上的元素查找耗时长，效率降低。

为了解决哈希冲突带了的链过长的问题，进行rehash操作，增加现有的哈希桶数量，分散单桶元素数量。那么rehash过程怎么样执行的呢？

字典进行扩容需要满足以下条件：

1. 哈希表中保存的key数量超过了哈希表的大小（可以看出size既是哈希表大小，同时也是扩容阈值）
2. 当前没有子进程在执行aof文件重写或者生成RDB文件；或者保存的节点数与哈希表大小的比例超过了安全阈值（默认值为5）　

为了使 rehash 操作更高效，使用两个全局哈希表：哈希表 1 和哈希表 2，具体如下：

- 将哈希表 2 分配更大的空间，

- 把哈希表 1 中的数据重新映射并拷贝到哈希表 2 中；

- 释放哈希表 1 的空间

但由于表1和表2在重新映射复制时数据大，如果一次性把哈希表 1 中的数据都迁移完，会造成 Redis 线程阻塞，无法服务其他请求。

为了避免这个问题，保证Redis能正常处理客户端请求，Redis 采用了渐进式 rehash。

每处理一个请求时，从哈希表 1 中依次将索引位置上的所有 entries 拷贝到哈希表 2 中，把一次性大量拷贝的开销，分摊到了多次处理请求的过程中，避免了耗时操作，保证了数据的快速访问。

![1.jpg](https://pict-picgo.oss-cn-hangzhou.aliyuncs.com/picture3/202209202143697.jpeg)

## 压缩列表

在数组基础上，在压缩列表在表头有三个字段 zlbytes、zltail 和 zllen，分别表示列表长度、列表尾的偏移量和列表中的 entry 个数；压缩列表在表尾还有一个 zlend，表示列表结束。

![image.png](https://gitee.com/sgkurisu/pic-go/raw/master/picture2/202111131438982.png)

优点：内存紧凑节省内存空间，内存中分配一块地址连续的空间，数据元素会挨着存放，不需要额外指针带来空间开销；查找定位第一个元素和最后一个元素，可以通过表头三个字段的长度直接定位，复杂度是 O(1)。

## 跳表

在链表的基础上，增加了多级索引，通过索引位置的几个跳转，实现数据的快速定位，如下图所示：

特点：当数据量很大时，跳表的查找复杂度为O(logN)。

查询33：

![2.jpg](https://gitee.com/sgkurisu/pic-go/raw/master/picture2/202111131439669.jpeg)

## 总结

各个底层数据查询时的时间复杂度：

| 数据结构类型 | 时间复杂度 |
| ------------ | ---------- |
| 哈希表       | O(1)       |
| 整数数组     | O(N)       |
| 双向列表     | O(N)       |
| 压缩列表     | O(N)       |
| 跳表         | O(logN)    |

# Redis 常用数据类型和底层数据类型之间的关系

Redis 中常用数据类型有 String、List、Hash、Sorted Set、Set，其与底层数据结构对应关系如下：

| 数据类型   | 数据结构           |
| ---------- | ------------------ |
| String     | SDS                |
| List       | 双向链表、压缩列表 |
| Hash       | 压缩列表、哈希表   |
| Sorted Set | 压缩列表、跳表     |
| Set        | 哈希表、整数数组   |

String，基于SDS实现，适用于简单key-value存储、setnx key value实现分布式锁、计数器(原子性)、分布式全局唯一ID。

List， 按照元素进入List 的顺序进行排序的，遵循FIFO(先进先出)规则，一般使用在 排序统计以及简单的消息队列。

Hash， 是字符串key和字符串value之间的映射，十分适合用来表示一个对象信息 ，特点添加和删除操作复杂度都是O(1)。

Set，是String 类型元素的无序集合，集合成员是唯一的，这就意味着集合中不能出现重复的数据。 基于哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。

Sorted Set， 是Set的类型的升级， 不同的是每个元素都会关联一个 double 类型的分数，通过分数排序，可以范围查询。

其他数据类型：

Redis Geo， 将地球看作为近似为球体，基于GeoHash 将二维的经纬度转换成字符串，来实现位置的划分跟指定距离的查询。特点一般使用在跟位置有关的应用。

HyperLogLog， 是一种概率数据结构，它使用概率算法来统计集合的近似基数 ， 错误率大概在0.81%。 当集合元素数量非常多时，它计算基数所需的空间总是固定的，而且还很小，适合使用做 UV 统计。

BitMap ，用一个比特位来映射某个元素的状态， 只有 0 和 1 两种状态，非常典型的二值状态，且其本身是用 String 类型作为底层数据结构实现的一种统计二值状态的数据类型 ，优势大量节省内存空间，可是使用在二值统计场景。

# Redis 的适用场景

**1、缓存**

>  缓存现在几乎是所有中大型网站都在用的必杀技，合理的利用缓存不仅能够提升网站访问速度，还能大大降低数据库的压力。Redis提供了键过期功能，也提供了灵活的键淘汰策略，所以，现在Redis用在缓存的场合非常多。 

**2、排行榜**

>  很多网站都有排行榜应用的，如淘宝的月度销量榜单、商品按时间的上新排行榜等。Redis提供的有序集合数据类构能实现各种复杂的排行榜应用。 

**3、计数器**

>  什么是计数器，如电商网站商品的浏览量、视频网站视频的播放数等。为了保证数据实时效，每次浏览都得给+1，并发量高时如果每次都请求数据库操作无疑是种挑战和压力。Redis提供的incr命令来实现计数器功能，内存操作，性能非常好，非常适用于这些计数场景。 

**4、分布式会话**

>  集群模式下，在应用不多的情况下一般使用容器自带的session复制功能就能满足，当应用增多相对复杂的系统中，一般都会搭建以Redis等内存数据库为中心的session服务，session不再由容器管理，而是由session服务及内存[数据库管理](https://cloud.tencent.com/product/dbbrain?from=10680)。 

**5、分布式锁**

>  在很多互联网公司中都使用了分布式技术，分布式技术带来的技术挑战是对同一个资源的并发访问，如全局ID、减库存、秒杀等场景，并发量不大的场景可以使用数据库的悲观锁、乐观锁来实现，但在并发量高的场合中，利用数据库锁来控制资源的并发访问是不太理想的，大大影响了数据库的性能。可以利用Redis的setnx功能来编写分布式的锁，如果设置返回1说明获取锁成功，否则获取锁失败，实际应用中要考虑的细节要更多。 

**6、 社交网络**

>  点赞、踩、关注/被关注、共同好友等是社交网站的基本功能，社交网站的访问量通常来说比较大，而且传统的关系数据库类型不适合存储这种类型的数据，Redis提供的哈希、集合等数据结构能很方便的的实现这些功能。 

**7、最新列表**

>  Redis列表结构，LPUSH可以在列表头部插入一个内容ID作为关键字，LTRIM可用来限制列表的数量，这样列表永远为N个ID，无需查询最新的列表，直接根据ID去到对应的内容页即可。 

**8、消息系统**

>  消息队列是大型网站必用中间件，如ActiveMQ、RabbitMQ、Kafka等流行的消息队列中间件，主要用于业务解耦、流量削峰及异步处理实时性低的业务。Redis提供了发布/订阅及阻塞队列功能，能实现一个简单的消息队列系统。另外，这个不能和专业的消息中间件相比。

实际应用选择

Set类型，适用统计用户/好友/关注/粉丝/感兴趣的人集合聚合操作，比如

- 统计手机APP每天的新增用户数
- 两个用户的共同好友

Redis中List 和 Sorted Set是有序集合，使用应对集合元素排序需求 ，比如

- 最新评论列表
- 排行榜

Bitmap二值状态统计，适用数据量大，且可以使用二值状态表示的统计，比如：

- 签到打卡，当天用户签到数
- 用户周活跃
- 用户在线状态

HyperLogLog 是一种用于统计基数的数据集合类型， 统计一个集合中不重复的元素个数 ，比如

- 统计网页的 UV ， 一个用户一天内的多次访问只能算作一次

# 总结

Redis之所以那么快，是因为其基于内存的数据操作和使用Hash哈希表作为索引，其效率高，速度快，而且得益于其底层数据多样化使得其可以适用于众多场景，不同场景中选择合适的数据类型可以提升其查询性能。
