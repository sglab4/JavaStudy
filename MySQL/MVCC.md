参考 https://juejin.cn/post/7056583607929798692

# 1. 什么是 MVCC

 MVCC 就是在**尽量减少锁使用**的情况下高效避免这些问题。

MySQL 四大隔离级别：

| 隔离级别                   | 脏读     | 不可重复读 | 幻读     |
| -------------------------- | -------- | ---------- | -------- |
| READ UNCOMMITTED：未提交读 | 可能发生 | 可能发生   | 可能发生 |
| READ COMMITTED：已提交读   | 解决     | 可能发生   | 可能发生 |
| REPEATABLE READ：可重复读  | 解决     | 解决       | 可能发生 |
| SERIALIZABLE：可串行化     | 解决     | 解决       | 解决     |

MVCC 全称 Multi-Version Concurrency Control，即多版本并发控制，主要是为了提高数据库的并发性能。

同一行数据平时发生读写请求时，会上锁阻塞住。但 MVCC 用更好的方式去处理读写请求，**做到在发生读写请求冲突时不用加锁**。

这个读是指的快照读，而不是当前读，当前读是一种加锁操作，是悲观锁。

# 2. 快照读和当前读

**快照读**

快照读，读取的是**快照数据**，不加锁的普通 SELECT 都属于快照读。

**当前读**

当前读就是读的是**最新数据**，而不是历史的数据，加锁的 SELECT，或者对数据进行增删改都会进行当前读。

# 3. 为什么使用 MVCC

**在数据库并发场景中**，只有**读-读**之间的操作才可以并发执行，**读-写**，**写-读**，**写-写**操作都要阻塞，这样就会导致 MySQL 的并发性能极差。

采用了 MVCC 机制后，只有写写之间相互阻塞，其他三种操作都可以并行，这样就可以提高了 MySQL 的并发性能。

# 4. MVCC机制的原理

它的实现原理主要是`版本链`，`undo日志` ，`Read View`来实现的。

## 4.1 版本链

在之前对 InnoDB 存储引擎的介绍了数据页的行格式，对于使用它的表来说，表中的聚簇索引都包含三个隐藏列：

| 列名             | 是否必须 | 说明                                                         |
| ---------------- | -------- | ------------------------------------------------------------ |
| row_id           | 否       | 创建的表中有主键或者非 NULL的 UNIQUE 键时都不会包含 row_id 列 |
| **trx_id**       | 是       | 事务ID，每次一个事务对某条聚簇索引记录进行改动时，都会把该事务的事务 id 赋值给 trx_id 隐藏列 |
| **roll_pointer** | 是       | 回滚指针，每次对某条聚簇索引记录进行改动时，都会把旧的版本写入到 undo 日志中，然后这个隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息 |

每次对记录进行改动，都会记录一条 undo 日志，每条 undo 日志也都有一个 roll_pointer 属性（INSERT 操作对应的 undo 日志没有该属性，因为该记录并没有更早的版本），可以将这些 undo 日志都连起来，串成一个链表，所以现在的情况就像下图一样：

![image-20211209091759865](https://pict-picgo.oss-cn-hangzhou.aliyuncs.com/picture3/202208211442533.webp)

对该记录每次更新后，都会将旧值放到一条 undo 日志中，就算是该记录的一个旧版本，随着更新次数的增多，所有的版本都会被 roll_pointer 属性连接成一个链表，我们把这个链表称之为**版本链**，版本链的头节点就是当前记录最新的值。

另外，每个版本中还包含生成该版本时对应的事务 id。于是可以利用这个记录的版本链来控制并发事务访问相同记录的行为，那么这种机制就被称之为**多版本并发控制（MVCC）** 。

## 4.2 undo日志

undo log 主要用于记录数据被`修改之前`的日志，在表信息修改之前先会把数据拷贝到`undo log`里。当`事务`进行`回滚时`可以通过 undo log 里的日志进行`数据还原`。

**Undo log 的用途**：

- 保证`事务`进行`rollback`时的`原子性和一致性`，当事务进行`回滚`的时候可以用undo log的数据进行`恢复`。
- 用于MVCC`快照读`的数据，在MVCC多版本控制中，通过读取`undo log`的`历史版本数据`可以实现`不同事务版本号`都拥有自己`独立的快照数据版本`。

**undo log主要分为两种**：

- `insert undo log`

  代表事务在insert新记录时产生的undo log , 只在事务回滚时需要，并且在事务提交后可以被立即丢弃。

- `update undo log`

  事务在进行 update 或 delete 时产生的 undo log， 不仅在事务回滚时需要，在快照读时也需要。所以不能随便删除，只有在快速读或事务回滚不涉及该日志时，对应的日志才会被 purge 线程统一清除。

## 4.3 ReadView

事务进行**快照读**操作的时候就会产生 Read View，它保存了**当前事务开启时所有活跃的事务列表**。

**注**：这里的活跃指的是**未提交**的事务。

每一个事务在启动时，都会生成一个 ReadView，用来记录一些内容，ReadView 中主要包含 4 个比较重要的属性：

| 属性           | 说明                                                         |
| -------------- | ------------------------------------------------------------ |
| m_ids          | 生成 ReadView 时当前系统中活跃的读写事务的事务 id 列表       |
| min_trx_id     | 生成 ReadView 时当前系统中活跃的读写事务中最小的事务 id 也就是 m_ids 中的最小值 |
| max_trx_id     | 生成 ReadView 时系统中应该分配给下一个事务的 id 值           |
| creator_trx_id | 生成该 ReadView 的事务的事务 id，指定当前的 ReadView 属于哪个事务 |

其中，`max_trx_id`并不是指`m_ids`中的最大值，因为事务 id 是递增分配的，假如现在有 id 为 1，2，3 这三个事务，之后 id 为 3 的事务提交了。那么一个新的读事务在生成 ReadView 时，m_ids 就包括 1 和 2，`min_trx_id` 的值就是 1，`max_trx_id` 的值就是 4。

再有了 ReadView 之后，在访问某条记录时，只需要按照下边的步骤判断记录的某个版本是否可见：

1. `trx_id = creator_trx_id` ，**可访问**

   如果被访问版本的 trx_id 属性值与 ReadView 中的 creator_trx_id 值相同，意味着当前事务在访问它自己修改过的记录，所以该版本可以被当前事务访问。

2. `trx_id < min_trx_id` ，**可访问**

   如果被访问版本的 trx_id 属性值小于 ReadView 中的 min_trx_id 值，表明生成该版本的事务在当前事务生成 ReadView 前已经提交，所以该版本可以被当前事务访问。

3. `trx_id >= max_trx_id` ，**不可访问**

   如果被访问版本的 trx_id 属性值大于或等于 ReadView 中的 max_trx_id 值，表明生成该版本的事务在当前事务生成 ReadView 后才开启，所以该版本不可以被当前事务访问。

4. `min_trx_id <= trx_id < max_trx_id`，**存在 `m_ids` 列表中不可访问**

   如果被访问版本的 trx_id 属性值在 ReadView 的 min_trx_id 和 max_trx_id 之间，那就需要判断一下 trx_id 属性值是不是在 m_ids 列表中，如果在，说明创建 ReadView 时生成该版本的事务还是活跃的，该版本不可以被访问；如果不在，说明创建 ReadView 时生成该版本的事务已经被提交，该版本可以被访问。

5. 某个版本的数据对当前事务不可见

   如果某个版本的数据对当前事务不可见的话，那就顺着版本链找到下一个版本的数据，继续按照上边的步骤判断可见性，依此类推，直到版本链中的最后一个版本。如果最后一个版本也不可见的话，那么就意味着该条记录对该事务完全不可见，查询结果就不包含该记录。

在 MySQL 中，READ COMMITTED 和 REPEATABLE READ 隔离级别的的一个非常大的区别就是它们**生成 ReadView 的时机不同**。在 READ COMMITTED 级别下每次**读取数据前**都生成一个 ReadView。在 REPEATABLE READ 级别下在**第一次**读取数据时生成一个 ReadView。

# 5. MVCC下的幻读现象

通过上面分分析我们知道，`REPEATABLE READ` 隔离级别下 MVCC 可以**解决不可重复读**问题。

那么幻读呢？MVCC 是怎么解决的？

幻读是一个事务按照某个相同条件多次读取记录时，后读取时读到了之前没有读到的记录，而这个记录来自另一个事务添加的新记录，也就是说幻读是指**新插入的行**。

为什么在 RR 级别下会出现幻读的情况呢？

仍然上面的那条数据，此时我们先查询一下数据库：


![image-20211210111725651](https://pict-picgo.oss-cn-hangzhou.aliyuncs.com/picture3/202208211449525.webp)

然后我们开启 2 个事务，事务 A 和事务 B。

**事务 A**

很明显，这个时候数据表中并没有 `id = 2`的数据。

![image-20211210112258314](https://pict-picgo.oss-cn-hangzhou.aliyuncs.com/picture3/202208211449405.webp)

**事务 B**

然后，我们在事务 B 中插入一条`id = 2`的数据。



然后回到事务 A，执行：

```sql
SELECT * FROM `user` WHERE id = 2;
```

此时为了保证 RR 下的可重复读，还是查询不到数据的。

但是我们 A 事务下执行以下操作，却发现能够修改成功：

```sql
UPDATE `user` SET name = 'a' WHERE id = 2;
```

![image-20211210112844702](https://pict-picgo.oss-cn-hangzhou.aliyuncs.com/picture3/202208211450632.webp)

再次在 A 事务下执行：

```sql
SELECT * FROM `user` WHERE id = 2;
```

![image-20211210113035832](https://pict-picgo.oss-cn-hangzhou.aliyuncs.com/picture3/202208211450005.webp)

事务 A 之前都不能查询出`id=2`的数据，现在竟然可以查到了，很明显出现了幻读现象。

在 REPEATABLE READ 隔离级别下，事务 A 第一次执行普通的 SELECT 语句时生成了一个 **ReadView**（且在 RR 下只会生成一个 RV），之后事务 B 向 user 表中新插入一条记录并提交。

ReadView 并不能阻止事务 A 执行 UPDATE 或者 DELETE 语句来改动这个新插入的记录（由于事务 B 已经提交，因此改动该记录并不会造成阻塞），但是这样一来，这条新记录的 `trx_id` 隐藏列的值就变成了事务 A 的事务 id。之后 A 再使用普通的 SELECT 语句去查询这条记录时就可以看到这条记录了，也就可以把这条记录返回给客户端。

因为这个特殊现象的存在，我们也可以认为 **MVCC 并不能完全禁止幻读**。

可使用临键锁 Next-Key Locks 来解决幻读问题
