参考 https://www.cnblogs.com/michael9/p/12497992.html

# 1、MySQL 整体架构

MySQL 在整体架构上分为 Server 层和存储引擎层。其中 Server 层，包括连接器、查询缓存、分析器、优化器、执行器等，存储过程、触发器、视图和内置函数都在这层实现。数据引擎层负责数据的存储和提取，如 InnoDB、MyISAM、Memory 等引擎。在客户端连接到 Server 层后，Server 会调用数据引擎提供的接口，进行数据的变更。

![img](https://pict-picgo.oss-cn-hangzhou.aliyuncs.com/picture3/202111131059464.png)

## 连接器

负责和客户端建立连接，获取用户权限以及维持和管理连接。

通过 `show processlist;` 来查询连接的状态。在用户建立连接后，即使管理员改变连接用户的权限，也不会影响到已连接的用户。默认连接时长为 8 小时，超过时间后将会被断开。

简单说下长连接：

优势：在连接时间内，客户端一直使用同一连接，避免多次连接的资源消耗。

劣势：在 MySQL 执行时，使用的内存被连接对象管理，由于长时间没有被释放，会导致系统内存溢出，被系统kill. 所以需要定期断开长连接，或执行大查询后，断开连接。MySQL 5.7 后，可以通过 `mysql_rest_connection` 初始化连接资源，不需要重连或者做权限验证。

## 查询缓存

当接受到查询请求时，会现在查询缓存中查询（key/value保存），是否执行过。没有的话，再走正常的执行流程。

## 分析器

对查询语句进行词法分析和语法分析

词法分析：

如识别 select，表名，列名，判断其是否存在等。

语法分析：

判断语句是否符合 MySQL 语法。

## 优化器

确定索引的使用，join 表的连接顺序等，选择最优化的方案。

## 执行器

在具体执行语句前，会先进行权限的检查，通过后使用数据引擎提供的接口，进行查询。如果设置了慢查询，会在对应日志中看到 `rows_examined` 来表示扫描的行数。在一些场景下（索引），执行器调用一次，但在数据引擎中扫描了多行，所以**引擎扫描的行数和 rows_examined 并不完全相同。**

# 2、日志模块

MySQL 整体分为 Server 层和存储引擎层，而每层也对应了自己的日志文件。如果选用的是 InnoDB 引擎，对应的是 redo log 文件。Server 层则对应了 binlog 文件。

## redo log

redo log 是 InnoDB 特有日志，为什么要引入 redo log 呢，想象这样一个场景，MySQL 为了保证持久性是需要把数据写入磁盘文件的。我们知道，在写入磁盘时，会进行文件的 IO，查找操作，如果每次更新操作都这样的话，整体的效率就会特别低，根本没法使用。

既然直接写入磁盘不行，解决方法就是先写进内存，在系统空闲时再更新到磁盘就可以了。但光更新内存不行，假如系统出现异常宕机和重启，内存中没有被写入磁盘的数据就会被丢掉，数据的一致性就出现问题了。这时 redo log 就发挥了作用，在更新操作发生时，InnoDb 会先写入 redo log 日志（记录了数据发生了怎么样的改变），同时更新内存，最后在适当的时间再写入磁盘，一般是找系统空闲的时间做。**先写日志，在写磁盘的操作，就是常说到的 WAL （Write-Ahead- Logging）技术。**

**redo log 的出现，除了在效率上有了很大的改善，还保证了 MySQL 具有了 crash-safe 的能力，在发生异常情况下，不会丢失数据。**

## bin log

binlog 则是 Server 层的日志，主要用于归档，在备份，主备同步，恢复数据时发挥作用

> redo log 和 binlog 的区别：

1. 所有者不同，binlog 是 Server 层，所有引擎都可使用。redo log 是引擎层， InnoDB 特有的。
2. 类型不同，binlog 是逻辑日志，记录的是语句的原始逻辑（比 statement）。redo log 是物理日志，记录某个数据页被做了怎样的修改。
3. 数据写入的方式不同，binog 日志会一直追加，而 redo log 是循环写入。
4. 功能不同，binlog 用于归档，而 redo log 用于保证 crash-safe.

# 3、SQL 语句如何执行

## 两阶段提交

执行 update 时的内部流程：

以更新 `update T set c=c+1 where ID=2;` 语句为例：

1. 执行器通过 InooDB 引擎去 ID 所在行，ID 为主键。引擎通过树搜索找到该行，如果该行所在数据页在内存中，返回给执行器。否则先从磁盘读入内存，然后再返回。
2. 执行器拿到引擎给的数据，将 C 值加 1，等到新的一行，然后通过引擎接口重新写入新数据。
3. 引擎将该行更新到内存中，同时将该更新操作记录到 **redo log** 中，并更改 redo log 的状态为 prepare 状态。然后告知执行器，在合适的时间提交事务。
4. 执行器生成这个操作的 **bin log**，并将 bin log 写入磁盘。
5. 执行器调用引擎到的提交事务接口，将刚刚写入的 redo log 改成 commit 状态，更新完成。

![img](https://pict-picgo.oss-cn-hangzhou.aliyuncs.com/picture3/202111131106111.png)

浅色为执行器执行，深色为引擎执行。

在更新内存后，将写入 redo log 拆分了成两个步骤：prepare 和 commit，就是常说的**两阶段提交，用于保证当有意外情况发生时，数据的一致性。**

> 不使用两阶段提交的后果

1. 先写 redo log，后写 bin log。在写入 redo log 后，未写入 binlog，此时若数据库发生异常，当再次启动数据库后，由于 redo log 正常，数据库内容没有问题，若想使用 bin log 进行备份，则会出现数据不一致的问题。
2. 先写 bin log，后写 redo log。写入 bin log 而未写入 redo log 时，若数据库发生异常，当再次启动数据库后，由于 redo log未写入该数据，认为该数据无效，但是在 bin log 中多了一条数据，造成数据不一致的问题。

> 两阶段提交的过程

1. 在写 redo log prepare 阶段崩溃，时刻 A 的位置。重启后，发现 redo log 没写入，回滚此次事务。
2. 如果在写 binlog 时奔溃，重启后，发现 binlog 未被写入，回滚操作。
3. binlog 写完，但在提交 redo log 的 commit 状态时发生崩溃.
   1. 如果 redo log 中事务完整，有了 commit 标识，直接提交。
   2. 如果 redo log 中只有完整的 prepare, 判断对应 binlog 是否完整。
      1. 完整，提交事务
      2. 不完整，回滚事务。

## 查询语句

sql 可以分为两种，一种是查询，一种是更新（增加，更新，删除）。我们先分析下查询语句，语句如下：

```sql
select * from tb_student  A where A.age='18' and A.name=' 张三 ';
```

结合上面的说明，我们分析下这个语句的执行流程：

* 先检查该语句是否有权限，如果没有权限，直接返回错误信息，如果有权限，在 MySQL8.0 版本以前，会先查询缓存，以这条 sql 语句为 key 在内存中查询是否有结果，如果有直接缓存，如果没有，执行下一步。

* 通过分析器进行词法分析，提取 sql 语句的关键元素，比如提取上面这个语句是查询 select，提取需要查询的表名为 tb_student,需要查询所有的列，查询条件是这个表的 id='1'。然后判断这个 sql 语句是否有语法错误，比如关键词是否正确等等，如果检查没问题就执行下一步。

* 接下来就是优化器进行确定执行方案，上面的 sql 语句，可以有两种执行方案：

      a.先查询学生表中姓名为“张三”的学生，然后判断是否年龄是 18。
      b.先找出学生中年龄 18 岁的学生，然后再查询姓名为“张三”的学生。

  那么优化器根据自己的优化算法进行选择执行效率最好的一个方案（优化器认为，有时候不一定最好）。那么确认了执行计划后就准备开始执行了。

* 进行权限校验，如果没有权限就会返回错误信息，如果有权限就会调用数据库引擎接口，返回引擎的执行结果。

## 更新语句

sql 语句如下：

```sql
update tb_student A set A.age='19' where A.name=' 张三 ';
```

我们来给张三修改下年龄，在实际数据库肯定不会设置年龄这个字段的，不然要被技术负责人打的。其实条语句也基本上会沿着上一个查询的流程走，只不过执行更新的时候肯定要记录日志啦，这就会引入日志模块了，MySQL 自带的日志模块式 **binlog（归档日志）** ，所有的存储引擎都可以使用，我们常用的 InnoDB 引擎还自带了一个日志模块 **redo log（重做日志）**，我们就以 InnoDB 模式下来探讨这个语句的执行流程。流程如下：

* 先查询到张三这一条数据，如果有缓存，也是会用到缓存。
* 然后拿到查询的语句，把 age 改为 19，然后调用引擎 API 接口，写入这一行数据，InnoDB 引擎把数据保存在内存中，同时记录 redo log，此时 redo log 进入 prepare 状态，然后告诉执行器，执行完成了，随时可以提交。
* 执行器收到通知后记录 binlog，然后调用引擎接口，提交 redo log 为提交状态。
* 更新完成。

**这里肯定有同学会问，为什么要用两个日志模块，用一个日志模块不行吗?**

这是因为最开始 MySQL 并没与 InnoDB 引擎( InnoDB 引擎是其他公司以插件形式插入 MySQL 的) ，MySQL 自带的引擎是 MyISAM，但是我们知道 redo log 是 InnoDB 引擎特有的，其他存储引擎都没有，这就导致会没有 crash-safe 的能力(crash-safe 的能力即使数据库发生异常重启，之前提交的记录都不会丢失)，binlog 日志只能用来归档。

并不是说只用一个日志模块不可以，只是 InnoDB 引擎就是通过 redo log 来支持事务的。那么，又会有同学问，我用两个日志模块，但是不要这么复杂行不行，为什么 redo log 要引入 prepare 预提交状态？这里我们用反证法来说明下为什么要这么做？

* **先写 redo log 直接提交，然后写 binlog**，假设写完 redo log 后，机器挂了，binlog 日志没有被写入，那么机器重启后，这台机器会通过 redo log 恢复数据，但是这个时候 bingog 并没有记录该数据，后续进行机器备份的时候，就会丢失这一条数据，同时主从同步也会丢失这一条数据。
* **先写 binlog，然后写 redo log**，假设写完了 binlog，机器异常重启了，由于没有 redo log，本机是无法恢复这一条记录的，但是 binlog 又有记录，那么和上面同样的道理，就会产生数据不一致的情况。

如果采用 redo log 两阶段提交的方式就不一样了，写完 binglog 后，然后再提交 redo log 就会防止出现上述的问题，从而保证了数据的一致性。那么问题来了，有没有一个极端的情况呢？假设 redo log 处于预提交状态，binglog 也已经写完了，这个时候发生了异常重启会怎么样呢？
这个就要依赖于 MySQL 的处理机制了，MySQL 的处理过程如下：

* 判断 redo log 是否完整，如果判断是完整的，就立即提交。
* 如果 redo log 只是预提交但不是 commit 状态，这个时候就会去判断 binlog 是否完整，如果完整就提交 redo log, 不完整就回滚事务。

这样就解决了数据一致性的问题。
